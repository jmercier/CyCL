cimport opencl
cimport libopencl

cdef dict error_translation_table = \
        {  CL_DEVICE_NOT_FOUND : "CL_DEVICE_NOT_FOUND",
           CL_DEVICE_NOT_AVAILABLE : "CL_DEVICE_NOT_AVAILABLE",
           CL_COMPILER_NOT_AVAILABLE : "CL_COMPILER_NOT_AVAILABLE",
           CL_MEM_OBJECT_ALLOCATION_FAILURE : "CL_MEM_OBJECT_ALLOCATION_FAILURE",
           CL_OUT_OF_RESOURCES : "CL_OUT_OF_RESOURCES",
           CL_OUT_OF_HOST_MEMORY : "CL_OUT_OF_HOST_MEMORY",
           CL_PROFILING_INFO_NOT_AVAILABLE : "CL_PROFILING_INFO_NOT_AVAILABLE",
           CL_MEM_COPY_OVERLAP : "CL_MEM_COPY_OVERLAP",
           CL_IMAGE_FORMAT_MISMATCH : "CL_IMAGE_FORMAT_MISMATCH",
           CL_IMAGE_FORMAT_NOT_SUPPORTED : "CL_IMAGE_FORMAT_NOT_SUPPORTED",
           CL_BUILD_PROGRAM_FAILURE : "CL_BUILD_PROGRAM_FAILURE",
           CL_MAP_FAILURE : "CL_MAP_FAILURE",
           CL_INVALID_VALUE : "CL_INVALID_VALUE",
           CL_INVALID_DEVICE_TYPE : "CL_INVALID_DEVICE_TYPE",
           CL_INVALID_PLATFORM : "CL_INVALID_PLATFORM",
           CL_INVALID_DEVICE : "CL_INVALID_DEVICE",
           CL_INVALID_CONTEXT : "CL_INVALID_CONTEXT",
           CL_INVALID_QUEUE_PROPERTIES : "CL_INVALID_QUEUE_PROPERTIES",
           CL_INVALID_COMMAND_QUEUE : "CL_INVALID_COMMAND_QUEUE",
           CL_INVALID_HOST_PTR : "CL_INVALID_HOST_PTR",
           CL_INVALID_MEM_OBJECT : "CL_INVALID_MEM_OBJECT",
           CL_INVALID_IMAGE_FORMAT_DESCRIPTOR : "CL_INVALID_IMAGE_FORMAT_DESCRIPTOR",
           CL_INVALID_IMAGE_SIZE : "CL_INVALID_IMAGE_SIZE",
           CL_INVALID_SAMPLER : "CL_INVALID_SAMPLER",
           CL_INVALID_BINARY : "CL_INVALID_BINARY",
           CL_INVALID_BUILD_OPTIONS : "CL_INVALID_BUILD_OPTIONS",
           CL_INVALID_PROGRAM : "CL_INVALID_PROGRAM",
           CL_INVALID_PROGRAM_EXECUTABLE : "CL_INVALID_PROGRAM_EXECUTABLE",
           CL_INVALID_KERNEL_NAME : "CL_INVALID_KERNEL_NAME",
           CL_INVALID_KERNEL_DEFINITION : "CL_INVALID_KERNEL_DEFINITION",
           CL_INVALID_KERNEL : "CL_INVALID_KERNEL",
           CL_INVALID_ARG_INDEX : "CL_INVALID_ARG_INDEX",
           CL_INVALID_ARG_VALUE : "CL_INVALID_ARG_VALUE",
           CL_INVALID_ARG_SIZE : "CL_INVALID_ARG_SIZE",
           CL_INVALID_KERNEL_ARGS : "CL_INVALID_KERNEL_ARGS",
           CL_INVALID_WORK_DIMENSION : "CL_INVALID_WORK_DIMENSION",
           CL_INVALID_WORK_GROUP_SIZE : "CL_INVALID_WORK_GROUP_SIZE",
           CL_INVALID_WORK_ITEM_SIZE : "CL_INVALID_WORK_ITEM_SIZE",
           CL_INVALID_GLOBAL_OFFSET : "CL_INVALID_GLOBAL_OFFSET",
           CL_INVALID_EVENT_WAIT_LIST : "CL_INVALID_EVENT_WAIT_LIST",
           CL_INVALID_EVENT : "CL_INVALID_EVENT",
           CL_INVALID_OPERATION : "CL_INVALID_OPERATION",
           CL_INVALID_GL_OBJECT : "CL_INVALID_GL_OBJECT",
           CL_INVALID_BUFFER_SIZE : "CL_INVALID_BUFFER_SIZE",
           CL_INVALID_MIP_LEVEL : "CL_INVALID_MIP_LEVEL",
           CL_INVALID_GLOBAL_WORK_SIZE : "CL_INVALID_GLOBAL_WORK_SIZE",
           -1001 : "CL_PLATFORM_NOT_FOUND_KHR"}

cdef dict device_type_translation_table = \
            { CL_DEVICE_TYPE_DEFAULT : "DEFAULT",
              CL_DEVICE_TYPE_CPU : "CPU",
              CL_DEVICE_TYPE_GPU : "GPU",
              CL_DEVICE_TYPE_ACCELERATOR : "ACCELERATOR" }

cdef CLError translateError(cl_int error):
    return CLError(error_translation_table[error])

DEF MAX_OPENCL_PLATFORM_NUMBER                  = 10
DEF MAX_OPENCL_DEVICES_NUMBER                   = 10

cdef _getPlatformInfo(cl_platform_id platform, cl_platform_info param_name):
    cdef char value[100]
    cdef size_t size
    CL_SAFE_CALL clGetPlatformInfo(platform, param_name, sizeof(char) * 100, <void *>value, &size)
    s = value[:size -1]
    return s

cdef _getDeviceInfo_string(cl_device_id device, cl_device_info param_name):
    cdef char value[100]
    cdef size_t size
    CL_SAFE_CALL clGetDeviceInfo(device, param_name, sizeof(char) * 100, <void *>value, &size)
    s = value[:size -1]
    return s

cdef cl_uint _getDeviceInfo_uint(cl_device_id device, cl_device_info param_name) except *:
    cdef cl_uint value
    cdef size_t size
    CL_SAFE_CALL clGetDeviceInfo(device, param_name, sizeof(value), <void *>&value, &size)
    return value

cdef cl_bool _getDeviceInfo_bool(cl_device_id device, cl_device_info param_name) except *:
    cdef cl_bool value
    cdef size_t size
    CL_SAFE_CALL clGetDeviceInfo(device, param_name, sizeof(value), <void *>&value, &size)
    return value

cdef cl_ulong _getDeviceInfo_ulong(cl_device_id device, cl_device_info param_name) except *:
    cdef cl_ulong value
    cdef size_t size
    CL_SAFE_CALL clGetDeviceInfo(device, param_name, sizeof(value), <void *>&value, &size)
    return value

cdef unsigned int _getDeviceInfo_vect(cl_device_id device, cl_device_info param_name, void *vect, size_t in_size) except *:
    cdef size_t size
    CL_SAFE_CALL clGetDeviceInfo(device, param_name, in_size, vect, &size)
    return size

cdef unsigned int _getDeviceInfo_size_t(cl_device_id device, cl_device_info param_name) except *:
    cdef size_t value
    cdef size_t size
    CL_SAFE_CALL clGetDeviceInfo(device, param_name, sizeof(value), &value, &size)
    return size

cdef class CLObject:
    def __init__(self):
        raise AttributeError("Sorry pal, no instantiation from Python ...")

cdef class CLDevice(CLObject):
    property driverVersion:
        def __get__(self):
            return _getDeviceInfo_string(self._device, CL_DRIVER_VERSION)

    property version:
        def __get__(self):
            return _getDeviceInfo_string(self._device, CL_DEVICE_VERSION)

    property vendor:
        def __get__(self):
            return _getDeviceInfo_string(self._device, CL_DEVICE_VENDOR)

    property profile:
        def __get__(self):
            return _getDeviceInfo_string(self._device, CL_DEVICE_PROFILE)

    property name:
        def __get__(self):
            return _getDeviceInfo_string(self._device, CL_DEVICE_NAME)

    property extensions:
        def __get__(self):
            return _getDeviceInfo_string(self._device, CL_DEVICE_EXTENSIONS)

    property addressBits:
        def __get__(self):
            return _getDeviceInfo_uint(self._device, CL_DEVICE_ADDRESS_BITS)

    property vendorId:
        def __get__(self):
            return _getDeviceInfo_uint(self._device, CL_DEVICE_VENDOR_ID)

    property maxWorkItemDimensions:
        def __get__(self):
            return _getDeviceInfo_uint(self._device, CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS)

    property maxWorkItemSizes:
        def __get__(self):
            cdef size_t itemSizes[100]
            cdef cl_uint dim = _getDeviceInfo_uint(self._device, CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS)
            _getDeviceInfo_vect(self._device, CL_DEVICE_MAX_WORK_ITEM_SIZES, itemSizes, 100 * sizeof(size_t))
            cdef int i
            cdef tuple t = (itemSizes[1],)
            for i in xrange(1, dim):
                t += (itemSizes[i],)
            return t

    property maxClockFrequency:
        def __get__(self):
            return _getDeviceInfo_uint(self._device, CL_DEVICE_MAX_CLOCK_FREQUENCY)

    property maxComputeUnit:
        def __get__(self):
            return _getDeviceInfo_uint(self._device, CL_DEVICE_MAX_COMPUTE_UNITS)

    property maxConstantArgs:
        def __get__(self):
            return _getDeviceInfo_uint(self._device, CL_DEVICE_MAX_CONSTANT_ARGS)

    property maxReadImageArgs:
        def __get__(self):
            return _getDeviceInfo_uint(self._device, CL_DEVICE_MAX_READ_IMAGE_ARGS)

    property maxSamplers:
        def __get__(self):
            return _getDeviceInfo_uint(self._device, CL_DEVICE_MAX_SAMPLERS)

    property minDataTypeAlignSize:
        def __get__(self):
            return _getDeviceInfo_uint(self._device, CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE)

    property maxWriteImageArgs:
        def __get__(self):
            return _getDeviceInfo_uint(self._device, CL_DEVICE_MAX_WRITE_IMAGE_ARGS)

    property memBaseAddrAlign:
        def __get__(self):
            return _getDeviceInfo_uint(self._device, CL_DEVICE_MEM_BASE_ADDR_ALIGN)

    property imageSupport:
        def __get__(self):
            return <bint>_getDeviceInfo_bool(self._device, CL_DEVICE_IMAGE_SUPPORT)

    property ECCSupport:
        def __get__(self):
            return <bint>_getDeviceInfo_bool(self._device, CL_DEVICE_ERROR_CORRECTION_SUPPORT)

    property endianLittle:
        def __get__(self):
            return <bint>_getDeviceInfo_bool(self._device, CL_DEVICE_ENDIAN_LITTLE)

    property compilerAvailable:
        def __get__(self):
            return <bint>_getDeviceInfo_bool(self._device, CL_DEVICE_COMPILER_AVAILABLE)

    property available:
        def __get__(self):
            return <bint>_getDeviceInfo_bool(self._device, CL_DEVICE_AVAILABLE)

    property globalMemSize:
        def __get__(self):
            return _getDeviceInfo_ulong(self._device, CL_DEVICE_GLOBAL_MEM_SIZE)

    property globalMemCacheSize:
        def __get__(self):
            return _getDeviceInfo_ulong(self._device, CL_DEVICE_GLOBAL_MEM_CACHE_SIZE)

    property globalMemCachelineSize:
        def __get__(self):
            return _getDeviceInfo_ulong(self._device, CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE)

    property localMemSize:
        def __get__(self):
            return _getDeviceInfo_ulong(self._device, CL_DEVICE_LOCAL_MEM_SIZE)

    property maxConstantBufferSize:
        def __get__(self):
            return _getDeviceInfo_ulong(self._device, CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE)

    property maxMemAllocSize:
        def __get__(self):
            return _getDeviceInfo_ulong(self._device, CL_DEVICE_MAX_MEM_ALLOC_SIZE)

    property image2DMaxSize:
        def __get__(self):
            cdef size_t width = _getDeviceInfo_size_t(self._device, CL_DEVICE_IMAGE2D_MAX_HEIGHT)
            cdef size_t height = _getDeviceInfo_size_t(self._device, CL_DEVICE_IMAGE2D_MAX_WIDTH)

            return (width, height)

    property image3DMaxSize:
        def __get__(self):
            cdef size_t width = _getDeviceInfo_size_t(self._device, CL_DEVICE_IMAGE3D_MAX_HEIGHT)
            cdef size_t height = _getDeviceInfo_size_t(self._device, CL_DEVICE_IMAGE3D_MAX_WIDTH)
            cdef size_t depth = _getDeviceInfo_size_t(self._device, CL_DEVICE_IMAGE3D_MAX_DEPTH)

            return (width, height, depth)


    property maxWorkGroupSize:
        def __get__(self):
            return _getDeviceInfo_size_t(self._device, CL_DEVICE_MAX_WORK_GROUP_SIZE)

    property profilingTimerResolution:
        def __get__(self):
            return _getDeviceInfo_size_t(self._device, CL_DEVICE_PROFILING_TIMER_RESOLUTION)

    property preferredVectorWidthChar:
        def __get__(self):
            return _getDeviceInfo_uint(self._device, CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR)

    property preferredVectorWidthShort:
        def __get__(self):
            return _getDeviceInfo_uint(self._device, CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT)

    property preferredVectorWidthInt:
        def __get__(self):
            return _getDeviceInfo_uint(self._device, CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT)

    property preferredVectorWidthLong:
        def __get__(self):
            return _getDeviceInfo_uint(self._device, CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG)

    property preferredVectorWidthFloat:
        def __get__(self):
            return _getDeviceInfo_uint(self._device, CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT)

    property preferredVectorWidthDouble:
        def __get__(self):
            return _getDeviceInfo_uint(self._device, CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE)

    property type:
        def __get__(self):
            return device_type_translation_table[_getDeviceInfo_ulong(self._device, CL_DEVICE_TYPE)]


cdef class CLPlatform(CLObject):
    cdef cl_platform_id _platform
    cdef cl_device_id _devices[MAX_OPENCL_DEVICES_NUMBER]
    cdef cl_uint _num_devices

    cpdef CLDevice getDevice(self, unsigned int device):
        if device >= self._num_devices:
            raise AttributeError("Invalid Device ID")
        cdef CLDevice instance = CLDevice.__new__(CLDevice)
        instance._device = self._devices[device]
        return instance

    property version:
        def __get__(self):
            return _getPlatformInfo(self._platform, CL_PLATFORM_VERSION)

    property name:
        def __get__(self):
            return _getPlatformInfo(self._platform, CL_PLATFORM_NAME)

    property vendor:
        def __get__(self):
            return _getPlatformInfo(self._platform, CL_PLATFORM_VENDOR)

    property extensions:
        def __get__(self):
            return _getPlatformInfo(self._platform, CL_PLATFORM_EXTENSIONS)

    property profile:
        def __get__(self):
            return _getPlatformInfo(self._platform, CL_PLATFORM_PROFILE)


cdef class CLBuffer(CLObject):
    cdef cl_mem _mem

    CL_DEALLOC clReleaseMemObject(self._mem)


cdef class CLContext(CLObject):
    cdef cl_context _context
    cdef list _devices

    CL_DEALLOC clReleaseContext (self._context)

    property devices:
        def __get__(self):
            return self._devices

    cpdef CLBuffer createBuffer(self, size_t size, size_t esize):
        cdef cl_int errcode
        cdef cl_mem buffer = clCreateBuffer(self._context, CL_MEM_READ_WRITE, size * esize, NULL, &errcode)
        cdef CLBuffer instance = CLBuffer.__new__(CLBuffer)
        instance._mem = buffer
        return instance

cdef cl_platform_id platforms[MAX_OPENCL_PLATFORM_NUMBER]
cdef unsigned int num_platforms

############################################
#
# OPENCL API
#
############################################

cpdef CLPlatform getPlatform(unsigned int pid):
    CL_SAFE_CALL clGetPlatformIDs(MAX_OPENCL_PLATFORM_NUMBER, platforms, &num_platforms)
    if pid >= num_platforms:
        raise AttributeError("Invalid platform ID")

    cdef CLPlatform instance = CLPlatform.__new__(CLPlatform)
    instance._platform = platforms[pid]

    CL_SAFE_CALL_NO_INIT clGetDeviceIDs(instance._platform, CL_DEVICE_TYPE_ALL, MAX_OPENCL_DEVICES_NUMBER, instance._devices, &instance._num_devices)
    return instance


cpdef CLContext createContext(list devices):
    cdef cl_device_id clDevices[100]
    cdef CLDevice device
    cdef cl_int errcode
    for i in xrange(len(devices)):
        device = devices[i]
        clDevices[i] = device._device
    cdef cl_context context = clCreateContext(NULL, len(devices), clDevices, NULL, NULL, &errcode)
    if errcode < 0:
        raise CLError(error_translation_table[errcode])

    cdef CLContext instance = CLContext.__new__(CLContext)
    instance._context = context
    instance._devices = devices
    return instance



